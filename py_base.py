"""
●●● PYTHON УЧЕБНЫЙ КОМПЕНДИУМ ●●●
"""

# ======================================
# ЧАСТЬ 0: ПОДГОТОВКА РАБОЧЕГО ОКРУЖЕНИЯ
# ======================================

# ======================================
# 0.1.1 Виртуальные окружения (.venv)
# ======================================
# ● Создание:
#   python -m venv venv  # Стандартный способ
#   python -m venv .venv # Альтернатива (скрытая папка)
# ● Активация:
#   ▸ Windows (CMD):
#     venv\Scripts\activate
#   ▸ Windows (PowerShell):
#     venv\Scripts\Activate.ps1
#   ▸ MacOS/Linux:
#     source venv/bin/activate
# ● Деактивация:
#   deactivate  # Работает во всех ОС

# ======================================
# 0.1.2 Управление пакетами (pip)
# ======================================
# ● Установка пакетов:
#   pip install requests  # Базовая установка
#   pip install numpy==1.21.0  # Конкретная версия
# ● Альтернативные репозитории:
#   pip install flask --index-url https://pypi.tuna.tsinghua.edu.cn/simple/  # Скачивает пакет с зеркала
#   pip config set global.index-url https://mirror.sbercloud.ru/pypi/simple/  # Меняет глобальную настройку на скачивание пакетов с зеркала
# ● Заморозка зависимостей:
#   pip freeze > requirements.txt  # Создание файла
#   pip install -r requirements.txt  # Установка из файла
# ● Пример requirements.txt:
#   Django==4.2.1  # Конкретная версия
#   psycopg2-binary>=2.9.5  # Не ниже определенной версии
#   python-dotenv  # Любая\последняя версия

# ======================================
# ЧАСТЬ 0.2: БАЗОВЫЙ СИНТАКСИС И СТИЛЬ (PEP8)
# ======================================

# ======================================
# 0.2.1 Правила оформления кода
# ======================================
# ● Отступы: 4 пробела (НЕ табы!)
#   Пробелы везде отображаются одинаково
#   Пробелы — это стандарт де-факто в Python-сообществе
#   Смешивание табов и пробелов может вызвать ошибки выполнения
# ● Имена переменных — маленькими буквами с подчёркиваниями: (пример: user_age)
# ● Имена переменных — маленькими буквами с подчёркиваниями: (пример: user_method)
# ● Имена классов — с заглавной буквы: (пример: UserClass)
# ● Константы — с заглавной буквы через подчёркивание: (пример: USER_NAME)

# ======================================
# 0.2.2 Организация кода
# ======================================
# ● Импорты группируются в порядке:
#   Стандартные библиотеки (import os)
#   Сторонние библиотеки (import django)
#   Локальные модули (from . import utils)
# ● Между группами - Пустые строки — отделяют логические блоки
#   Например, перед объявлением новой функции делаем одну пустую строку.
# ● Максимальная длина строки: 79 символов
# ● Пробелы вокруг операторов:
#   Правильно: x = y + z
#   Неправильно: x=y+z
# ● Комментарии понятные, описывают "зачем", а не "что".

"""
1. Комментарии и вывод на экран
"""
# Это однострочный комментарий
"""
Это многострочный комментарий.
Он может занимать несколько строк.
"""

# ● Интерпретатор Python выполняет команды ПОСТРОЧНО сверху вниз.
# ● То есть, он читает код как человек читает книгу — построчно, начиная с первой строки.
# ● Когда ты запускаешь программу, интерпретатор начинает выполнять каждую строку кода по порядку.
# Например:
print("Привет")  # Сначала выполнится эта строка
print("Мир")  # Затем — эта
# ● Если в коде встречается "ссылка" на другой модуль (например, импорт через import),
# ● Интерпретатор сначала ЗАГРУЗИТ этот модуль и тоже выполнит нужные строки из него, если требуется.
# Например:
import math  # Импортируется модуль math
print(math.sqrt(16))  # Теперь интерпретатор знает, как посчитать корень
# ● То же самое и с классами или функциями: они определяются один раз (интерпретатор "запоминает"),
# ● Но выполняются только когда их вызывают.

# Базовые функции:
# ● Функция print() выводит текст на экран
print("Hello, World!")  # Выведет: Hello, World!
# ● Функция input() запрашивает ввод данных
name = input("Как тебя зовут? ")  # Запросит ввод
print("Привет,", name, "!")  # Выведет: Привет, Иван!

"""
●●● 2. Переменные (variable) и типы данных (data type) ●●● 
"""
# ● Объявление переменных (тип не указан)
name = "Анна"  # Строка (str)
age = 25  # Целое число (int)
height = 1.75  # Число с плавающей точкой (float)
is_student = True  # Логическое значение (bool)
# ● Объявление переменных (тип указан)
name_2: str = "Анна"
age_2: int = 25
height_2: float = 1.75
is_student_2: bool = True

# ● Типы данных переменных
# int — integer (целое число)
# float — float (число с плавающей точкой)
# str — string (строка)
# bool — boolean (логическое значение)
# list — list (список)
# tuple — tuple (кортеж)
# set — set (множество)
# dict — dictionary (словарь)
# None — NoneType (отсутствие значения)

# ● Вывод значений переменных
print("Имя:", name)  # Печатает введённое имя
print("Возраст:", age)  # Печатает возраст, приведённый к int
print("Рост:", height)  # Печатает рост в метрах как float
print("Студент:", is_student)  # Печатает True, если ответ был "да", иначе False

# ● Ввод значений разных типов от пользователя
name = input("Введите ваше имя: ")  # Строка (тип str)
age = int(input("Введите ваш возраст: "))  # Целое число (тип int)
height = float(input("Введите ваш рост в метрах: "))  # Число с плавающей точкой (тип float)
is_student = input("Вы студент? (да/нет): ") == "да"  # Булевое значение (тип bool)

# ● Динамическая типизация - можно менять тип переменной
variable = 10  # Переменной variable присваивается значение 10 (тип int — целое число)
print(type(variable))  # Вывод: <class 'int'>

variable = "Теперь строка"  # Теперь той же переменной присваивается строка (тип str)
print(type(variable))  # Вывод: <class 'str'>

"""
●●● 3. Основные операторы ●●● 
"""
a = 10  # Простая числовая переменная
b = 3  # Простая числовая переменная

# ● Арифметические операторы
print(a + b)  # Сложение: 13
print(a - b)  # Вычитание: 7
print(a * b)  # Умножение: 30
print(a / b)  # Деление: 3.333...
print(a // b)  # Целочисленное деление: 3
print(a % b)  # Остаток от деления: 1
print(a ** b)  # Возведение в степень: 1000

# ● Операторы сравнения
print(a == b)  # Равно: False
print(a != b)  # Не равно: True
print(a > b)  # Больше: True
print(a < b)  # Меньше: False
print(a >= b)  # Больше или равно: True
print(a <= b)  # Меньше или равно: False

# ● Логические операторы
x = True  # bool (булево) значение ИСТИНЫ (верно)
y = False  # bool (булево) значение ЛЖИ (не верно)

print(x and y)  # И: возвращает True ТОЛЬКО если оба значения True.
# Здесь: True И False → результат: False
print(x or y)  # ИЛИ: возвращает True, если ХОТЯ БЫ одно значение True.
# Здесь: True ИЛИ False → результат: True
print(not x)  # НЕ: возвращает противоположное значение.
# Здесь: не True → результат: False

"""
●●● 4. Условные конструкции ●●● 
"""
# Простое условие if \ elif \ else
temperature = 23
if temperature > 30:  # Если температура больше 30
    print("Жарко")  # выполняется только если условие выше истинно
elif temperature > 20:  # Иначе, если больше 20 (но ≤ 30)
    print("Тепло")  # будет выполнено это
else:  # Если все условия выше ложны (temperature ≤ 20)
    print("Прохладно")  # выполняется этот блок

# ● Тернарный оператор (условное выражение в одну строку) - это короткий способ записать конструкцию if–else - <выражение_если_True> if <условие> else <выражение_если_False>
status = "Студент" if age < 25 else "Работяга"  # Краткая форма условия: если age < 25, то "Студент", а если нет то "Работяга"
print(status)  # Выводим результат

# ● Вложенные условия
score = 85  # Задаём переменную с числовым значением (например, оценка за тест)
if score >= 90:  # Проверяется первое условие: оценка 90 и выше
    print("Отлично")  # Если условие выполнено — выводится "Отлично"
else:  # Если первое условие НЕ выполнено (меньше 90), переходим в блок else
    if score >= 75:  # Здесь новое условие: оценка 75 и выше
        print("Хорошо")  # Если да — выводится "Хорошо"
    else:  # Если и это условие не выполнено (меньше 75)
        print("Удовлетворительно")  # Выводим "Удовлетворительно"

# ● Множество elif
grade = "B"  # Задаём переменную с буквенной оценкой (строка)
if grade == "A":  # Если оценка — "A"
    print("Отличная работа!")
elif grade == "B":  # Иначе если оценка — "B"
    print("Хорошо!")
elif grade == "C":  # Иначе если — "C"
    print("Могло быть лучше")
else:  # Если ни одно из условий выше не выполнено
    print("Нужно постараться")

# ● Без elif
if is_student:  # Если переменная is_student равна True (например, пользователь — студент)
    print("Скидка применена")  # Выполнится только в этом случае
# Если is_student = False — код просто "пройдёт мимо", и ничего не выведется


"""
●●● 5. Циклы ●●● 
"""
# Цикл for
print("Цикл for:")
for i in range(5):  # Цикл пройдётся по значениям от 0 до 4 (всего 5 итераций)
    print(i)  # На каждой итерации выводится текущее значение i
    # Первая итерация: i = 0  → выведет 0
    # Вторая итерация: i = 1  → выведет 1
    # Третья итерация: i = 2  → выведет 2
    # Четвёртая итерация: i = 3  → выведет 3
    # Пятая итерация: i = 4  → выведет 4

# Досрочное завершение цикла (break)
for i in range(10):  # Цикл пройдётся по числам от 0 до 9
    if i == 5:  # Как только i станет равно 5...
        break  # ...выполнение цикла остановится полностью
    print(i)  # Значения 0, 1, 2, 3, 4 будут выведены

# Пропуск итерации (continue)
for i in range(5):  # Цикл от 0 до 4
    if i == 2:  # Если i равно 2...
        continue  # ...эта итерация будет пропущена (но цикл продолжится)
    print(i)  # Выведет все значения, кроме 2

# Цикл for с list
fruits = ["яблоко", "банан", "вишня"]  # создаётся список из трёх фруктов
for fruit in fruits:  # цикл перебирает каждый элемент списка
    print(fruit)  # печатается текущий фрукт в каждой итерации перебора (3 фрукта)
    # На первой итерации: яблоко
    # На второй итерации: банан
    # На третьей итерации: вишня

# Цикл while
print("Цикл while:")
count = 0
while count < 3:  # Пока значение переменной меньше 3, выполняем тело цикла
    print(count)  # На каждой итерации печатаем текущее значение count
    count += 1  # Увеличиваем значение count на 1 (аналог count = count + 1)
    # Цикл while:
    # 0
    # 1
    # 2

# Бесконечный цикл (while true + break)
while True:  # Цикл никогда сам не завершится — условие всегда True
    answer = input("Продолжить? (д/н): ")  # Запрашиваем ввод пользователя
    if answer.lower() == "н":  # Если введено "н" (в любом регистре)...
        break  # ...выход из цикла

# ЦЕЛИ ЦИКЛОВ

# 1. Перебор элементов
items = ["яблоко", "банан", "груша"]  # Список из трёх фруктов
for item in items:  # Цикл перебирает каждый элемент в списке
    print(item)  # На каждой итерации выводит текущий фрукт
# ИЛИ со строкой
for char in "Python":  # Цикл перебирает каждый символ строки
    print(char)  # Выводится по одной букве: P, y, t, h, o, n

# 2. Повторить действие N раз
for _ in range(10):  # Цикл выполняется 10 раз. Переменная не используется — ставим "_"
    print("Привет!")  # Каждую итерацию печатаем "Привет!"
# ИЛИ со счётчиком
for i in range(1, 11):  # Цикл от 1 до 10 (всего 10 итераций)
    print(f"{i}. Привет!")  # Выводим номер итерации и текст

# 3. Обработка ввода до нужного условия
while True:  # Бесконечный цикл — будет работать, пока не прервётся вручную
    answer = input("Введите 'да' для продолжения: ")  # Запрос ввода от пользователя
    if answer.lower() == "да":  # Приводим ввод к нижнему регистру и проверяем
        break  # Если пользователь ввёл "да" — выходим из цикла
# ПРОСТАЯ ВАЛИДАЦИЯ
age = input("Сколько тебе лет? ")  # Получаем ввод (пока это строка)
while not age.isdigit():  # Пока строка НЕ состоит из цифр (например, "abc" или "12a")
    age = input("Введите число, а не текст: ")  # Просим ввести заново
# После выхода из цикла переменная age точно содержит число (но всё ещё как строка)

# 4. Автоматизация: проверка, подсчёт, фильтрация
numbers = [1, 4, 7, 10]  # Список чисел
for n in numbers:  # Перебираем каждое число
    if n % 2 == 0:  # Если остаток от деления на 2 — 0 (то есть число чётное)
        print(n, "— чётное")  # Выводим чётное число
# ПОДСЧЁТ
total = 0  # Обнуляем сумму перед началом
for n in numbers:  # Перебираем список чисел
    total += n  # Прибавляем каждое число к общей сумме
print("Сумма:", total)  # Выводим общую сумму после цикла

# ЦЕЛИ ЦИКЛОВ В АВТОТЕСТАХ

# 1. Перебор элементов
students = ["Аня", "Богдан", "Карина", "Женя"]  # Список имён
for name in students:  # Перебираем по одному имени
    print("Студент:", name)  # Выводим строку с именем

# 2. Счётчики и подсчёты
numbers = [4, 7, 2, 9]
total = 0  # Инициализируем счётчик
for num in numbers:  # Перебор каждого числа
    total += num  # Прибавляем к сумме
print("Сумма:", total)  # Итог

# 3. Проверка условий
for number in range(1, 11):  # Перебираем числа от 1 до 10
    if number % 2 == 0:  # Проверяем — чётное ли
        print(number, "— чётное")  # Если да — печатаем

# 4. Ввод до правильного ответа
while True:  # Бесконечный цикл
    password = input("Введите пароль: ")  # Ввод пароля
    if password == "python123":  # Если пароль верный
        print("Доступ разрешён.")  # Сообщаем
        break  # И выходим из цикла

# 5. Генерация данных
import random  # импорт библиотеки работы с рандомным вводом
import string  # импорт библиотеки работы со строчным вводом

for _ in range(10):  # Сгенерировать 10 паролей
    password = ""  # Начинаем с пустой строки
    for _ in range(8):  # Каждый пароль — 8 символов
        password += random.choice(string.ascii_letters + string.digits)  # Добавляем случайную букву или цифру
    print("Пароль:", password)  # Выводим сгенерированный пароль

"""
●●● 6. Функции ●●● 
"""


# 6.1. Определение функции
def greet(name):  # Определяем функцию с именем greet, которая принимает один аргумент name
    """Эта функция приветствует пользователя"""  # Докстрока: пояснение, что делает функция
    return "Привет, " + name + "!"  # Возвращаем строку с приветствием


# Вызов функции 6.1.
message = greet("Иван")  # Вызываем функцию, передаём строку "Иван", результат сохраняем в переменную message
print(message)  # Печатаем возвращённое значение: "Привет, Иван!"


# 6.2. Типы аргументов функции
def demo(*args, **kwargs):  # Функция принимает любое количество позиционных и именованных аргументов
    print("Позиционные:", args)  # args — кортеж всех позиционных аргументов
    print("Именованные:", kwargs)  # kwargs — словарь всех именованных аргументов


# Вызов функции 6.2.
demo(1, 2, 3, a=4, b=5)


# Позиционные: (1, 2, 3)   — переданы без указания имени
# Именованные: {'a': 4, 'b': 5}  — переданы как пары ключ=значение

# 6.3. Аннотации типов аргументов (Type Hints)
def add(a: int, b: int) -> int:  # Указываем, что оба аргумента типа int, и результат тоже int
    return a + b  # вывод → возвращает результат сложения значений переменных a и b


add_result_one = add(3, 5)
print(add_result_one)  # вывод → Выведет 8
print(add(10, 7))  # вывод → Выведет 17


# Проверка работы функций
def multiply(a, b):  # Простая функция, возвращающая произведение
    return a * b


assert multiply(2, 3) == 6, "Умножение не работает!"  # Проверяем, вернёт ли функция ожидаемый результат


# ПРИМЕР ФУНКЦИИ
def check_temperature(temp):
    if temp > 30:  # Если температура выше 30 градусов,
        print("На улице жарко")

    elif 15 <= temp <= 30:  # Если температура в пределах от 15 до 30 включительно,
        print("Погода комфортная")

    else:  # Этот блок выполняется, если не подошли предыдущие условия,
        print("Прохладно или холодно")


# Примеры запуска
check_temperature(35)  # вывод → На улице жарко
check_temperature(22)  # вывод → Погода комфортная
check_temperature(5)  # вывод → Прохладно или холодно

"""
●●● 7. Коллекции данных ●●● 
"""

# Список (list) — изменяемая упорядоченная коллекция
numbers = [1, 2, 3, 4, 5]  # Создаём список из 5 чисел
print(numbers[0])  # вывод → первый элемент списка: 1 (индексация с нуля)
print(numbers[-1])  # вывод → последний элемент: 5 (индекс -1 — это последний элемент)
# Добавляем число 6 в конец списка
numbers.append(6)  # вывод → [1, 2, 3, 4, 5, 6]
# вставка элемента в позицию первого значения
numbers.insert(5, 6)  # вывод → [1, 2, 3, 4, 5, 6]
# добавление всех элементов другого списка
a = [1, 2]
b = [3, 4]
a.extend(b)  # вывод → [1, 2, 3, 4]
# удаляет первое вхождение элемента
colors = ["red", "green", "blue", "green"]
colors.remove("green")  # вывод → ["red", "blue", "green"]
# удаляет элемент с позиции 1 и возвращает его
nums = [10, 20, 30]
val = nums.pop(1)  # вывод → val = 20, nums = [10, 30]
# возвращает индекс первого вхождения элемента
letters = ["a", "b", "c"]
i = letters.index("b")  ## вывод → i = 1
# считает количество вхождений элемента
nums = [1, 2, 2, 3, 2]
nums.count(2)  # вывод → 3
# сортирует список по возрастанию
values = [3, 1, 4, 2]
values.sort()  # вывод → [1, 2, 3, 4]
# разворачивает порядок элементов
values = [1, 2, 3]
values.reverse()  # вывод → [3, 2, 1]
# удаляет все элементы списка
my_list = [1, 2, 3]
my_list.clear()  # вывод → []

# Кортеж (tuple) — неизменяемая коллекция
coordinates = (10.0, 20.0, 20.0)  # Кортеж из двух координат (например, x и y)
print(coordinates[1])  # Обращаемся ко второму элементу кортежа: 20.0

coordinates.count(20.0)  # Возвращает количество вхождений значения x ~ вернет 2
coordinates.index(10.0)  # Возвращает индекс первого вхождения x ~ вернет 0

# Множество (set) — неупорядоченная коллекция уникальных элементов
unique_numbers = {1, 2, 2, 3}  # Повторяющееся значение 2 автоматически убирается
print(unique_numbers)  # Выведет {1, 2, 3}

# Словарь (dict) — коллекция пар ключ-значение
person = {
    "name": "Анна",  # Ключ "name" содержит строку "Анна"
    "age": 25,  # Ключ "age" содержит целое число 25
    "city": "Москва"  # Ключ "city" содержит строку "Москва"
}
print(person["name"])  # Выводим значение по ключу "name": Анна
print(person.keys())  # возвращает все ключи словаря → dict_keys(['name', 'age', 'city'])
print(person.values())  # возвращает все значения словаря → dict_values(['Анна', 25, 'Москва'])
print(person.get("name"))  # безопасно получить значение по ключу → Анна
print(person.get("email"))  # безопасно получить значение по ключу → None (не вызовет ошибку)
print(person.get("email", "не указано"))  # Можно задать значение по умолчанию → не указано
person.update({"age": 26, "email": "anna@example.com"})  # обновляет/добавляет ключи и значения
print(person)  # вывод → {'name': 'Анна', 'age': 26, 'city': 'Москва', 'email': 'anna@example.com'}
del person["city"]  # удаляет элемент по ключу
print(person)  # вывод → {'name': 'Анна', 'age': 26, 'email': 'anna@example.com'}

# Добавляем новое поле
person["email"] = "anna@example.com"
# Обновляем возраст
person["age"] = 26
# Проверяем, есть ли ключ
if "city" in person:
    print("Город указан:", person["city"])
# Перебираем все ключи и значения и возвращает пары (ключ, значение)
for key, value in person.items():
    print(f"{key.capitalize()}: {value}")
# Удаляем поле
del person["email"]


# ПРИМЕР В ФУНКЦИИ
def print_data_summary(numbers, coords, seen_ids, person_info):
    # Определяем функцию с именем print_data_summary.
    # Она принимает 4 аргумента:
    # numbers — список чисел
    # coords — кортеж координат (x, y)
    # seen_ids — множество уникальных ID
    # person_info — словарь с данными о человеке

    print("🔢 Числа:")
    for i, num in enumerate(numbers):
        # Перебираем элементы списка numbers с помощью enumerate(),
        # чтобы получить как индекс (i), так и значение (num)
        print(f"{i + 1}) {num}")  # Выводим каждый элемент с нумерацией, начиная с 1

    print("\n📍 Координаты:")
    print(f"X: {coords[0]}, Y: {coords[1]}")
    # Обращаемся к элементам кортежа по индексу:
    # coords[0] — координата X, coords[1] — координата Y

    print("\n🧮 Уникальные ID:")
    for uid in seen_ids:
        # Перебираем элементы множества seen_ids
        # Порядок может быть произвольным, так как set неупорядочен
        print(f"- {uid}")

    print("\n🙋 Информация о человеке:")
    for key, value in person_info.items():
        # Перебираем пары ключ-значение из словаря person_info
        # Метод .items() возвращает и ключ, и соответствующее значение
        print(f"{key.capitalize()}: {value}")
        # Метод capitalize() делает первую букву ключа заглавной (для красоты)


# Вызов
nums = [10, 20, 30]  # список целых чисел
coordinates = (55.75, 37.61)  # кортеж с двумя числами (пример: широта и долгота)
ids = {101, 102, 101, 103}  # множество, повтор 101 будет удалён автоматически
person = {"name": "Иван", "age": 30, "city": "Новосибирск"}  # словарь с данными о человеке

print_data_summary(nums, coordinates, ids, person)

# Вызов функции сразу с "встроенными" аргументами
print_data_summary(
    [10, 20, 30],  # список numbers
    (55.75, 37.61),  # кортеж координат
    {101, 102, 101, 103},  # множество (повтор 101 будет удалён)
    {"name": "Иван", "age": 30, "city": "Новосибирск"}  # словарь
)

# 1. Функция, возвращающая список (list)
def get_even_numbers(n):
    return [i for i in range(n) if i % 2 == 0]
# Пример:
print(get_even_numbers(10))  # вывод → [0, 2, 4, 6, 8]

# 2. Функция, возвращающая кортеж (tuple)
def get_coordinates():
    x = 12.5
    y = 7.8
    return (x, y)
# Пример:
print(get_coordinates())  # вывод → (12.5, 7.8)

# 3. Функция, возвращающая множество (set)
def unique_letters(word):
    return set(word)
# Пример:
print(unique_letters("программа"))  # вывод → {'г', 'м', 'о', 'а', 'р', 'п'}

# 4. Функция, возвращающая словарь (dict)
def create_person(name, age):
    return {
        "name": name,
        "age": age,
        "is_adult": age >= 18
    }
# Пример:
print(create_person("София", 21))  # вывод → {'name': 'София', 'age': 21, 'is_adult': True}

"""
●●● 8. Работа со строками ●●● 
"""

text = "Python - мощный язык программирования"
print(text[0:6])  # вывод → 'Python' — срез с 0 по 5 индекс
print(text[-13:])  # вывод → 'программирования' — последние 13 символов

# Длина строки
print(len(text))  # вывод → 36

# Built-in функции

# Преобразование регистра
print(text.upper())  # вывод → ВСЯ СТРОКА ЗАГЛАВНЫМИ
print(text.lower())  # вывод → вся строка строчными
print(text.capitalize())  # вывод → Первая буква заглавная, остальные строчные
print(text.title())  # вывод → Заглавные буквы в начале каждого слова

# Удаление пробелов и символов
bad_text = "   Привет, мир!   "
print(bad_text.strip())  # вывод → Удаляет пробелы в начале и конце
print(bad_text.lstrip())  # вывод → Только слева
print(bad_text.rstrip())  # вывод → Только справа

# Поиск подстрок
print(text.find("язык"))  # вывод → индекс начала слова 'язык', либо -1 если не найдено
print("Python" in text)  # вывод → True, если 'Python' есть в строке

# Замена подстроки
new_text = text.replace("мощный", "гибкий")
print(new_text)  # вывод → 'Python - гибкий язык программирования'

# Разделение строки
words = text.split()  # вывод → ['Python', '-', 'мощный', 'язык', 'программирования']

# Подсчёт количества вхождений
text2 = "а роза упала на лапу азора"
print(text2.count("а"))  # вывод → считает количество символов "а"

# Объединение строк
words = ["код", "—", "это", "поэзия"]
sentence = " ".join(words)
print(sentence)  # вывод → 'код — это поэзия'

# Проверки содержимого строки
s = "Python3"
print(s.isalpha())  # вывод → False — есть цифры
print(s.isdigit())  # вывод → False
print(s.isalnum())  # вывод → True — только буквы и цифры, без пробелов

# Форматирование строк
name = "Алина"
age = 28
city = "Казань"
height = 1.68  # типо в метрах

# 1. Старый способ (%)
print("Имя: %s, Возраст: %d" % (name, age))  # вывод → Имя: Алина, Возраст: 28
print("Имя: %s, Возраст: %d, Город: %s, Рост: %.2f м" % (name, age, city, height))  # вывод → Имя: Алина, Возраст: 28, Город: Казань, Рост: 1.68 м

# 2. Метод format()
print("Имя: {}, Возраст: {}".format(name, age))  # вывод → Имя: Алина, Возраст: 28
print("Имя: {n}, Город: {c}".format(n=name, c=city))  # вывод → Имя: Алина, Возраст: 28
print("Имя: {}, Возраст: {}, Город: {}, Рост: {:.2f} м".format(name, age, city, height))  # вывод → Имя: Алина, Возраст: 28, Город: Казань, Рост: 1.68 м

# 3. f-строки (Python 3.6+)
print(f"Имя: {name}, Возраст: {age}")  # вывод → Имя: Алина, Возраст: 28
print(f"Имя: {name}, Возраст: {age}, Город: {city}, Рост: {height:.2f} м")  # вывод → Имя: Алина, Возраст: 28, Город: Казань, Рост: 1.68 м

"""
●●● 9. Обработка исключений ●●● 
"""
# Исключение — это ошибка, которая возникает во время выполнения программы. Вместо того чтобы аварийно завершать выполнение, Python может “поймать” ошибку и дать нам шанс обработать её, чтобы программа не рухнула.

# ПРИМЕР
a = 10
b = 0
try:
    result = a / b
except ZeroDivisionError:
    print("Ошибка: Деление на ноль невозможно!")
# ПРИМЕР
text = "123a"
try:
    number = int(text)
except ValueError:
    print("Ошибка: невозможно преобразовать строку в целое число!")

# Вариации конструкции
# try / except / else
try:
    result = 5 / 1
except ZeroDivisionError:
    print("Ошибка деления")
else:  # else выполняется, только если ошибок не было.
    print("Успешно! Результат:", result)
# try / except / finally
try:
    file = open("data.txt")
except FileNotFoundError:
    print("Файл не найден")
finally:
    print("Этот блок выполнится в любом случае")

# Обработка нескольких исключений
try:
    num = int(input("Введите число: "))
    result = 10 / num
except ValueError:
    print("Ошибка: Введите корректное число")
except ZeroDivisionError:
    print("Ошибка: Деление на ноль")


# Пример функции с исключениями
def get_value(d, key):
    try:
        return d[key]  # Пытаемся вернуть значение по ключу
    except KeyError:  # Если ключа нет — перехватываем исключение
        return "Ключ не найден"
# Использование
data = {"name": "Ирина", "city": "Москва"}
print(get_value(data, "name"))  # вывод → Ирина
print(get_value(data, "age"))  # вывод → Ключ не найден


# Полезные исключения, которые часто встречаются
# ZeroDivisionError - Деление на 0
# ValueError - Неверный тип значения (например, int("abc"))
# TypeError - Операции между несовместимыми типами (3 + "hi")
# IndexError - Выход за границы списка
# KeyError - Нет такого ключа в словаре
# FileNotFoundError - Попытка открыть несуществующий файл
# AttributeError - Обращение к несуществующему методу или атрибуту
# ImportError - Ошибка при импорте модуля - import nonexistent_module
# ModuleNotFoundError - Не найден модуль при импорте - import unknown_module
# NameError - Обращение к переменной, которая не определена - print(a) (если a не существует)
# UnboundLocalError - Использование локальной переменной до её объявления - внутри функции: print(x); x = 3
# IndentationError - Ошибка отступов - Пропущен отступ после if:
# SyntaxError - Ошибка синтаксиса - if x > 3 print("hi")
# MemoryError - Заканчивается доступная оперативная память - Обычно — в больших вычислениях
# RecursionError - Превышена глубина рекурсии - Бесконечный вызов функции
# EOFError - input() не может прочитать данные (конец ввода) - input() в скрипте без ввода
# RuntimeError - Общая ошибка выполнения, не попадающая под другие категории - Часто в библиотеках
# OSError - Ошибки операционной системы	Ошибка чтения файла, нехватка прав
# PermissionError - Нет прав на доступ к ресурсу - open("/etc/shadow") без root
# IsADirectoryError - Попытка открыть каталог как файл - open("папка/")
# NotADirectoryError - Ожидался каталог, а оказалось файлом	os.listdir("файл.txt")
# TimeoutError - Время ожидания операции истекло - Например, в сетевых запросах
# StopIteration - Цикл по итератору завершён - Внутри генератора или next()
# AssertionError - Неудовлетворённое утверждение через assert - assert 2 + 2 == 5

"""
●●● 10. Работа с ОС, файлами и путями ●●● 
"""

import os
import shutil
from pathlib import Path

# 10.1. Запись в файл
with open("example.txt", "w", encoding="utf-8") as file:
    file.write("Привет, мир!\nЭто пример записи в файл.")

# 10.2. Чтение из файла
with open("example.txt", "r", encoding="utf-8") as file:
    content = file.read()
    print("Содержимое файла:")
    print(content)

# 10.3. Проверка существования файла
file_exists = os.path.exists("example.txt")
print(f"\nФайл существует: {file_exists}")

# 10.4. Получение информации о файле
if file_exists:
    file_info = os.stat("example.txt")
    print(f"Размер файла: {file_info.st_size} байт")
    print(f"Время последнего изменения: {file_info.st_mtime}")

# 10.5. Работа с путями
current_dir = os.getcwd()
print(f"\nТекущая рабочая директория: {current_dir}")

file_path = os.path.join(current_dir, "example.txt")
print(f"Полный путь к файлу: {file_path}")

# 10.6. Создание новой директории
new_dir = "test_dir"
if not os.path.exists(new_dir):
    os.mkdir(new_dir)
    print(f"\nСоздана директория: {new_dir}")

# 10.7. Копирование файла
copied_file = os.path.join(new_dir, "example_copy.txt")
shutil.copy2("example.txt", copied_file)
print(f"Файл скопирован в: {copied_file}")

# 10.8. Работа с Path из pathlib
path = Path("example.txt")
print(f"\nИмя файла (через pathlib): {path.name}")
print(f"Родительская директория: {path.parent}")
print(f"Расширение файла: {path.suffix}")

# 10.9. Чтение файла построчно
print("\nЧтение файла построчно:")
with open("example.txt", "r", encoding="utf-8") as file:
    for i, line in enumerate(file, 1):
        print(f"Строка {i}: {line.strip()}")

# 10.10. Добавление в файл
with open("example.txt", "a", encoding="utf-8") as file:
    file.write("\nЭто строка добавлена в конец файла.")

print("\nФайл после добавления:")
with open("example.txt", "r", encoding="utf-8") as file:
    print(file.read())

# 10.11. Удаление файла и директории
os.remove(copied_file)
os.rmdir(new_dir)
print(f"\nУдалены копия файла и директория {new_dir}")

"""
●●● 11. Классы и ООП (Объектно-Ориентированное Программирование) ●●● 
"""
# Классы — это шаблоны для создания объектов.
# 11.1. Базовый класс - Простейший класс с атрибутами и методами.
class Person:
    # Конструктор класса (инициализатор)
    def __init__(self, name, age):
        self.name = name  # атрибут экземпляра
        self.age = age
    # Метод экземпляра класса
    def introduce(self):
        print(f"Меня зовут {self.name}, мне {self.age} лет.")
# Создание объекта (экземпляра класса)
person1 = Person("Иван", 30)
person1.introduce()  # Вывод: Меня зовут Иван, мне 30 лет.

# 11.2. Класс с наследованием - Наследование позволяет создавать новый класс на основе существующего. Наследование позволяет расширять функциональность.
class Student(Person):  # Наследуем от класса Person
    def __init__(self, name, age, university):
        super().__init__(name, age)  # Вызов конструктора родительского класса
        self.university = university
    def study(self):
        print(f"{self.name} учится в {self.university}.")
student1 = Student("Анна", 20, "МГУ")
student1.introduce()  # Метод родительского класса
student1.study()      # Метод дочернего класса

# 11.3. Инкапсуляция (сокрытие данных) - Использование приватных атрибутов (начинаются с _ или __). Инкапсуляция скрывает детали реализации.
class BankAccount:
    def __init__(self, balance):
        self.__balance = balance  # Приватный атрибут
    def deposit(self, amount):
        self.__balance += amount
    def get_balance(self):
        return self.__balance
account = BankAccount(1000)
account.deposit(500)
print(account.get_balance())  # 1500
# print(account.__balance)  # Ошибка! Атрибут приватный.

# 11.4. Полиморфизм - Разные классы могут иметь методы с одинаковыми именами, но разной реализацией. Полиморфизм дает возможность использовать одинаковые методы для разных классов.
class Cat:
    def speak(self):
        print("Мяу!")
class Dog:
    def speak(self):
        print("Гав!")
animals = [Cat(), Dog()]
for animal in animals:
    animal.speak()  # Вывод: Мяу! Гав!

# 11.5. Абстрактный класс - Класс, который не предназначен для создания экземпляров, а только для наследования. Абстрактные классы задают структуру для дочерних классов.
from abc import ABC, abstractmethod
class Shape(ABC):  # Абстрактный класс
    @abstractmethod
    def area(self):
        pass
class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius
    def area(self):
        return 3.14 * self.radius ** 2
# shape = Shape()  # Ошибка! Нельзя создать экземпляр абстрактного класса.
circle = Circle(5)
print(circle.area())  # 78.5

# 11.6. Статические методы и методы класса - Статические методы и методы класса работают без создания экземпляра.
# Статический метод (@staticmethod) — не требует доступа к экземпляру или классу.
# Метод класса (@classmethod) — работает с классом, а не с экземпляром.
class Math:
    @staticmethod
    def add(a, b):
        return a + b
    @classmethod
    def multiply(cls, a, b):
        return a * b
print(Math.add(2, 3))       # 5 (статический метод)
print(Math.multiply(2, 3))  # 6 (метод класса)

# 11.7. Класс с перегрузкой операторов - Можно переопределять поведение операторов (+, -, == и т. д.). Позволяет задать свою логику для операций.
class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    def __add__(self, other):  # Перегрузка оператора +
        return Vector(self.x + other.x, self.y + other.y)
    def __str__(self):
        return f"Vector({self.x}, {self.y})"
v1 = Vector(1, 2)
v2 = Vector(3, 4)
v3 = v1 + v2
print(v3)  # Vector(4, 6)

# 11.8. Синглтон (одиночка) - Класс, который может иметь только один экземпляр. Синглтон гарантирует единственный экземпляр класса.
class Singleton:
    _instance = None
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance
a = Singleton()
b = Singleton()
print(a is b)  # True (это один и тот же объект)

"""
●●● 12. Модули ●●● 
"""
# Модули в Python — это файлы с расширением .py, содержащие код (функции, классы, переменные), который можно повторно использовать в других программах.
# Импорты позволяют подключать модули и использовать их функционал.
# 12.1. Импорт всего модуля
import math  # Импорт стандартного модуля math
print(math.sqrt(16))  # 4.0 (используем math. перед функцией)
print(math.pi)        # 3.141592653589793
# Импорт всего содержимого модуля (не рекомендуется)
from math import *  # Импорт всех функций из math
print(sqrt(25))    # 5.0 (теперь можно без math.)

# 12.2. Импорт конкретных функций/классов
from random import randint, choice  # Импорт только randint и choice
print(randint(1, 10))          # Случайное число (например, 7)
print(choice(["a", "b", "c"])) # Случайный элемент (например, "b")

# 12.3. Импорт с псевдонимом (alias)
import numpy as np  # Стандартное сокращение для библиотеки numpy
import pandas as pd # Аналогично для pandas
arr = np.array([1, 2, 3])  # Вместо numpy.array

# 12.4. Импорт собственного модуля
# Создаем файл utils.py
def say_hello():
    print("Привет из другого файла!")
# Импортируем в файл main.py
from utils import say_hello
say_hello()

# 12.5. Относительный импорт (для пакетов)
# Структура проекта
"""
my_project/
    ├── main.py
    └── utils/
        ├── __init__.py
        └── helpers.py
"""
# Импорт в main.py из helpers.py
from utils.helpers import function  # Импорт из папки utils

# 12.6. Условный импорт - Импорт в зависимости от условий (например, для разных версий Python).
try:
    import simplejson as json  # Попробовать импортировать simplejson
except ImportError:
    import json                # Если нет, использовать стандартный json

# 12.7. Импорт внутри метода и чего угодно
def calculate_sqrt(x):
    import math  # импортируем только внутри функции
    return math.sqrt(x)
result = calculate_sqrt(16)
print(result)  # вывод 4.0
# ✅ Уместно:
# Когда модуль тяжёлый и нужен только при определённом сценарии
# Когда хочешь уменьшить время запуска основного кода
# В функциях-плагинах, которые используют сторонние библиотеки не всегда
# 🚫 Лучше избегать:
# Когда читаемость кода важнее (все импорты в начале — это читаемо)
# Если модуль нужен глобально и используется в разных частях кода
